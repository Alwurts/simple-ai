import { exec } from "node:child_process";
import { promises as fs } from "node:fs";
import path from "node:path";
import { promisify } from "node:util";

const execAsync = promisify(exec);

// Import registry from the ui-registry directory
const registryModule = await import("../registry/index.js");
const { registry } = registryModule;

const REGISTRY_ROOT = path.join(process.cwd(), "src/ui-registry");
const PROJECT_ROOT = process.cwd();

async function rimraf(path: string) {
	try {
		await fs.rm(path, { recursive: true, force: true });
	} catch {
		// Ignore errors
	}
}

async function buildRegistryIndex() {
	let index = `// @ts-nocheck
/** biome-ignore-all lint/suspicious/noExplicitAny: Needed */
// This file is autogenerated by scripts/build-registry.mts
// Do not edit this file directly.
import * as React from "react"

export const Index: Record<string, any> = {`;

	for (const item of registry.items) {
		const resolveFiles = item.files?.map((file) => `registry/${file.path}`);
		if (!resolveFiles || item.files?.length === 0) {
			continue;
		}

		const componentPath = item.files?.[0]?.path
			? `@/ui-registry/registry/${item.files[0].path}`
			: "";

		index += `
  "${item.name}": {
    name: "${item.name}",
    description: "${item.description ?? ""}",
    type: "${item.type}",
    registryDependencies: ${JSON.stringify(item.registryDependencies ?? [])},
    files: [${item.files?.map((file) => {
			const filePath = `./src/ui-registry/registry/${typeof file === "string" ? file : file.path}`;
			return typeof file === "string"
				? `"${filePath}"`
				: `{
      path: "${filePath}",
      type: "${file.type}",
      target: "${file.target ?? ""}"
    }`;
		})}],
    component: ${
			componentPath
				? `React.lazy(async () => {
      const mod = await import("${componentPath}")
      const exportName = Object.keys(mod).find(key => typeof mod[key] === 'function' || typeof mod[key] === 'object') || "${item.name}"
      return { default: mod.default || mod[exportName] }
    })`
				: "null"
		},
    categories: ${JSON.stringify(item.categories ?? [])},
    meta: ${JSON.stringify(item.meta ?? {})},
  },`;
	}

	index += `
}`;

	console.log(`#Ô∏è‚É£  ${registry.items.length} items found`);

	const indexPath = path.join(REGISTRY_ROOT, "registry/__index__.tsx");
	await rimraf(indexPath);
	await fs.writeFile(indexPath, index, "utf-8");
}

async function buildRegistryJsonFile() {
	const fixedRegistry = {
		...registry,
		items: registry.items.map((item) => {
			const files = item.files?.map((file) => {
				return {
					...file,
					path: `./src/ui-registry/registry/${file.path}`,
				};
			});

			return {
				...item,
				files,
			};
		}),
	};

	const registryJsonPath = path.join(PROJECT_ROOT, "registry.json");
	await rimraf(registryJsonPath);
	await fs.writeFile(registryJsonPath, JSON.stringify(fixedRegistry, null, 2), "utf-8");

	try {
		await execAsync(`biome check registry.json --write`);
	} catch {
		// Biome might not be available or file might not exist yet
	}

	const publicRPath = path.join(PROJECT_ROOT, "public/r");
	await fs.mkdir(publicRPath, { recursive: true });
	await fs.cp(registryJsonPath, path.join(publicRPath, "registry.json"), {
		recursive: true,
	});
}

async function buildRegistry() {
	return new Promise<void>((resolve, reject) => {
		const childProcess = exec(`npx shadcn build registry.json --output ./public/r`, {
			cwd: PROJECT_ROOT,
		});

		childProcess.stdout?.on("data", (data) => {
			console.log(data.toString().trim());
		});

		childProcess.stderr?.on("data", (data) => {
			console.error(data.toString().trim());
		});

		childProcess.on("error", (error) => {
			reject(new Error(`Failed to start shadcn build process: ${error.message}`));
		});

		childProcess.on("exit", (code) => {
			if (code === 0) {
				resolve();
			} else {
				reject(new Error(`shadcn build process exited with code ${code}`));
			}
		});
	});
}

async function buildBlocksIndex() {
	// Simple blocks index - we'll implement getAllRegistryItems later if needed
	const blocks = registry.items.filter((item) => item.type === "registry:block");

	const payload = blocks.map((block) => ({
		name: block.name,
		description: block.description,
		categories: block.categories,
	}));

	const blocksIndexPath = path.join(REGISTRY_ROOT, "registry/__blocks__.json");
	await rimraf(blocksIndexPath);
	await fs.writeFile(blocksIndexPath, JSON.stringify(payload, null, 2), "utf-8");

	try {
		await execAsync(`biome check src/ui-registry/registry/__blocks__.json --write`);
	} catch {
		// Biome might not be available
	}
}

try {
	console.log("üóÇÔ∏è Building registry/__index__.tsx...");
	await buildRegistryIndex();

	console.log("üóÇÔ∏è Building registry/__blocks__.json...");
	await buildBlocksIndex();

	console.log("üíÖ Building registry.json...");
	await buildRegistryJsonFile();

	console.log("üèóÔ∏è Building registry...");
	await buildRegistry();

	console.log("‚úÖ Registry build complete!");
} catch (error) {
	console.error(error);
	process.exit(1);
}
