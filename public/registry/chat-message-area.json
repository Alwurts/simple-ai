{
  "name": "chat-message-area",
  "type": "registry:ui",
  "registryDependencies": [
    "scroll-area",
    "button"
  ],
  "files": [
    {
      "path": "ui/chat-message-area.tsx",
      "content": "import { Button } from \"@/components/ui/button\";\nimport { ScrollArea } from \"@/components/ui/scroll-area\";\nimport { cn } from \"@/lib/utils\";\nimport { useScrollToBottom } from \"@/hooks/use-scroll-to-bottom\";\nimport { ChevronDown } from \"lucide-react\";\nimport type { ReactNode } from \"react\";\n\ntype ScrollButtonAlignment = \"left\" | \"center\" | \"right\";\n\ninterface ScrollButtonProps {\n\tonClick: () => void;\n\talignment?: ScrollButtonAlignment;\n\tclassName?: string;\n}\n\nexport function ScrollButton({\n\tonClick,\n\talignment = \"right\",\n\tclassName,\n}: ScrollButtonProps) {\n\tconst alignmentClasses = {\n\t\tleft: \"left-4\",\n\t\tcenter: \"left-1/2 -translate-x-1/2\",\n\t\tright: \"right-4\",\n\t};\n\n\treturn (\n\t\t<Button\n\t\t\tvariant=\"secondary\"\n\t\t\tsize=\"icon\"\n\t\t\tclassName={cn(\n\t\t\t\t\"absolute bottom-4 rounded-full shadow-lg hover:bg-secondary\",\n\t\t\t\talignmentClasses[alignment],\n\t\t\t\tclassName,\n\t\t\t)}\n\t\t\tonClick={onClick}\n\t\t>\n\t\t\t<ChevronDown className=\"h-4 w-4\" />\n\t\t</Button>\n\t);\n}\n\ninterface ChatMessageAreaProps {\n\tchildren: ReactNode;\n\tclassName?: string;\n\tscrollButtonAlignment?: ScrollButtonAlignment;\n}\n\nexport function ChatMessageArea({\n\tchildren,\n\tclassName,\n\tscrollButtonAlignment = \"right\",\n}: ChatMessageAreaProps) {\n\tconst [\n\t\tcontainerRef,\n\t\tshowScrollButton,\n\t\tscrollToBottom,\n\t] = useScrollToBottom<HTMLDivElement>();\n\n\treturn (\n\t\t<ScrollArea className=\"flex-1 relative\">\n\t\t\t<div ref={containerRef}>\n\t\t\t\t<div className={cn(className, \"min-h-0\")}>{children}</div>\n\t\t\t</div>\n\t\t\t{showScrollButton && (\n\t\t\t\t<ScrollButton\n\t\t\t\t\tonClick={scrollToBottom}\n\t\t\t\t\talignment={scrollButtonAlignment}\n\t\t\t\t\tclassName=\"absolute bottom-4 rounded-full shadow-lg hover:bg-secondary\"\n\t\t\t\t/>\n\t\t\t)}\n\t\t</ScrollArea>\n\t);\n}\n\nChatMessageArea.displayName = \"ChatMessageArea\";\n",
      "type": "registry:ui",
      "target": ""
    },
    {
      "path": "hooks/use-scroll-to-bottom.ts",
      "content": "import { type RefObject, useCallback, useEffect, useRef, useState } from \"react\";\n\nexport function useScrollToBottom<T extends HTMLElement>(): [\n\tRefObject<T>,\n\tboolean,\n\t() => void,\n] {\n\tconst containerRef = useRef<T>(null);\n\tconst [showScrollButton, setShowScrollButton] = useState(false);\n\tconst [shouldAutoScroll, setShouldAutoScroll] = useState(true);\n\tconst isUserScrolling = useRef(false);\n\tconst isGrowing = useRef(false);\n\n\tconst getViewport = useCallback((element: HTMLElement | null) => {\n\t\treturn element?.closest(\"[data-radix-scroll-area-viewport]\") as HTMLElement;\n\t}, []);\n\n\tconst isAtBottom = useCallback((viewport: HTMLElement) => {\n\t\tconst { scrollTop, scrollHeight, clientHeight } = viewport;\n\t\treturn Math.abs(scrollHeight - scrollTop - clientHeight) < 10;\n\t}, []);\n\n\tconst updateScrollState = useCallback((viewport: HTMLElement) => {\n\t\tconst { scrollHeight, clientHeight } = viewport;\n\t\tconst hasScrollableContent = scrollHeight > clientHeight;\n\t\tconst atBottom = isAtBottom(viewport);\n\t\t\n\t\tsetShowScrollButton(hasScrollableContent && !atBottom);\n\t\t\n\t\tif (!isUserScrolling.current) {\n\t\t\tsetShouldAutoScroll(atBottom);\n\t\t}\n\t}, [isAtBottom]);\n\n\tuseEffect(() => {\n\t\tconst container = containerRef.current;\n\t\tconst viewport = getViewport(container);\n\t\t\n\t\tif (!container || !viewport) {\n\t\t\treturn;\n\t\t}\n\n\t\tupdateScrollState(viewport);\n\n\t\tconst handleScroll = () => {\n\t\t\tif (!isUserScrolling.current) {\n\t\t\t\tupdateScrollState(viewport);\n\t\t\t}\n\t\t};\n\n\t\tconst handleTouchStart = () => {\n\t\t\tisUserScrolling.current = true;\n\t\t};\n\t\t\n\t\tconst handleTouchEnd = () => {\n\t\t\tisUserScrolling.current = false;\n\t\t\tupdateScrollState(viewport);\n\t\t};\n\n\t\tlet growthTimeout: number;\n\t\tconst observer = new MutationObserver(() => {\n\t\t\tisGrowing.current = true;\n\t\t\twindow.clearTimeout(growthTimeout);\n\t\t\t\n\t\t\tif (shouldAutoScroll && !isUserScrolling.current) {\n\t\t\t\tviewport.scrollTo({\n\t\t\t\t\ttop: viewport.scrollHeight,\n\t\t\t\t\t\n\t\t\t\t\tbehavior: \"instant\",\n\t\t\t\t});\n\t\t\t}\n\t\t\tupdateScrollState(viewport);\n\t\t\t\n\t\t\tgrowthTimeout = window.setTimeout(() => {\n\t\t\t\tisGrowing.current = false;\n\t\t\t}, 100);\n\t\t});\n\n\t\tviewport.addEventListener(\"scroll\", handleScroll, { passive: true });\n\t\tviewport.addEventListener(\"touchstart\", handleTouchStart);\n\t\tviewport.addEventListener(\"touchend\", handleTouchEnd);\n\n\t\tobserver.observe(container, {\n\t\t\tchildList: true,\n\t\t\tsubtree: true,\n\t\t\tattributes: true,\n\t\t\tcharacterData: true,\n\t\t});\n\n\t\treturn () => {\n\t\t\twindow.clearTimeout(growthTimeout);\n\t\t\tobserver.disconnect();\n\t\t\tviewport.removeEventListener(\"scroll\", handleScroll);\n\t\t\tviewport.removeEventListener(\"touchstart\", handleTouchStart);\n\t\t\tviewport.removeEventListener(\"touchend\", handleTouchEnd);\n\t\t};\n\t}, [getViewport, updateScrollState, shouldAutoScroll]);\n\n\tconst scrollToBottom = () => {\n\t\tconst viewport = getViewport(containerRef.current);\n\t\tif (!viewport) {\n\t\t\treturn;\n\t\t}\n\n\t\tsetShouldAutoScroll(true);\n\t\tviewport.scrollTo({\n\t\t\ttop: viewport.scrollHeight,\n\t\t\tbehavior: isGrowing.current ? \"instant\" : \"smooth\",\n\t\t});\n\t};\n\n\treturn [containerRef, showScrollButton, scrollToBottom];\n}\n",
      "type": "registry:hook",
      "target": ""
    }
  ]
}