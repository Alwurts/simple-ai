{
	"$schema": "https://ui.shadcn.com/schema/registry-item.json",
	"name": "jsx-utils",
	"type": "registry:lib",
	"description": "A set of utilities for working with JSX.",
	"files": [
		{
			"path": "./src/registry/lib/jsx-utils.ts",
			"content": "/**\n * Matches and extracts information about JSX tags in a string of code.\n * Handles three tag formats:\n * 1. Opening tags: <tag attr=\"value\">\n * 2. Self-closing tags: <tag />\n * 3. Closing tags: </tag>\n *\n * @param code - The string containing JSX code to analyze\n * @returns Object containing tag details or null if no match is found\n * @example\n * matchJsxTag('<div className=\"container\">');\n * // Returns:\n * // {\n * //   tag: '<div className=\"container\">',\n * //   tagName: 'div',\n * //   type: 'opening',\n * //   attributes: 'className=\"container\"',\n * //   startIndex: 0,\n * //   endIndex: 27\n * // }\n */\nexport function matchJsxTag(code: string) {\n\tif (code.trim() === \"\") {\n\t\treturn null;\n\t}\n\n\tconst tagRegex = /<\\/?([a-zA-Z][a-zA-Z0-9]*)\\s*([^>]*?)(\\/)?>/;\n\tconst match = code.match(tagRegex);\n\n\tif (!match || typeof match.index === \"undefined\") {\n\t\treturn null;\n\t}\n\n\tconst [fullMatch, tagName, attributes, selfClosing] = match;\n\tconst type = selfClosing\n\t\t? \"self-closing\"\n\t\t: fullMatch.startsWith(\"</\")\n\t\t\t? \"closing\"\n\t\t\t: \"opening\";\n\n\treturn {\n\t\ttag: fullMatch,\n\t\ttagName,\n\t\ttype,\n\t\tattributes: attributes.trim(),\n\t\tstartIndex: match.index,\n\t\tendIndex: match.index + fullMatch.length,\n\t};\n}\n\n/**\n * Completes any unclosed JSX tags in the provided code by adding their closing tags.\n * Maintains proper nesting order when adding closing tags.\n *\n * @param code - The JSX code string that may contain unclosed tags\n * @returns The completed JSX code with all necessary closing tags added\n * @example\n * completeJsxTag('<div><p');\n * // Returns: '<div></div>'\n */\nexport function completeJsxTag(code: string) {\n\tconst stack: string[] = [];\n\tlet result = \"\";\n\tlet currentPosition = 0;\n\n\twhile (currentPosition < code.length) {\n\t\tconst match = matchJsxTag(code.slice(currentPosition));\n\t\tif (!match) {\n\t\t\tbreak;\n\t\t}\n\n\t\tconst { tagName, type, endIndex } = match;\n\n\t\tif (type === \"opening\") {\n\t\t\tstack.push(tagName);\n\t\t} else if (type === \"closing\") {\n\t\t\tstack.pop();\n\t\t}\n\n\t\tresult += code.slice(currentPosition, currentPosition + endIndex);\n\t\tcurrentPosition += endIndex;\n\t}\n\n\treturn (\n\t\tresult +\n\t\tstack\n\t\t\t.reverse()\n\t\t\t.map((tag) => `</${tag}>`)\n\t\t\t.join(\"\")\n\t);\n}\n\n/**\n * Extracts JSX content from inside a return statement in the provided code.\n *\n * @param code - The code string containing a return statement with JSX\n * @returns The extracted JSX content as a string, or null if no content is found\n * @example\n * extractJsxContent('function Component() { return (<div>Hello</div>); }');\n * // Returns: '<div>Hello</div>'\n */\nexport function extractJsxContent(code: string): string | null {\n\tconst returnContentRegex = /return\\s*\\(\\s*([\\s\\S]*?)(?=\\s*\\);|\\s*$)/;\n\tconst match = code.match(returnContentRegex);\n\n\tif (match?.[1]) {\n\t\treturn match[1].trim();\n\t}\n\n\treturn null;\n}\n",
			"type": "registry:lib"
		}
	]
}
