{
  "name": "use-scroll-to-bottom",
  "type": "registry:hook",
  "files": [
    {
      "path": "hooks/use-scroll-to-bottom.ts",
      "content": "\"use client\";\n\nimport {\n\ttype RefObject,\n\tuseCallback,\n\tuseEffect,\n\tuseRef,\n\tuseState,\n} from \"react\";\n\nexport function useScrollToBottom<T extends HTMLElement>(): [\n\tRefObject<T>,\n\tboolean,\n\t() => void,\n] {\n\tconst containerRef = useRef<T>(null);\n\tconst [showScrollButton, setShowScrollButton] = useState(false);\n\tconst [shouldAutoScroll, setShouldAutoScroll] = useState(true);\n\tconst isUserScrolling = useRef(false);\n\tconst isGrowing = useRef(false);\n\n\tconst getViewport = useCallback((element: HTMLElement | null) => {\n\t\treturn element?.closest(\"[data-radix-scroll-area-viewport]\") as HTMLElement;\n\t}, []);\n\n\tconst isAtBottom = useCallback((viewport: HTMLElement) => {\n\t\tconst { scrollTop, scrollHeight, clientHeight } = viewport;\n\t\treturn Math.abs(scrollHeight - scrollTop - clientHeight) < 10;\n\t}, []);\n\n\tconst updateScrollState = useCallback(\n\t\t(viewport: HTMLElement) => {\n\t\t\tconst { scrollHeight, clientHeight } = viewport;\n\t\t\tconst hasScrollableContent = scrollHeight > clientHeight;\n\t\t\tconst atBottom = isAtBottom(viewport);\n\n\t\t\tsetShowScrollButton(hasScrollableContent && !atBottom);\n\n\t\t\tif (!isUserScrolling.current) {\n\t\t\t\tsetShouldAutoScroll(atBottom);\n\t\t\t}\n\t\t},\n\t\t[isAtBottom],\n\t);\n\n\tuseEffect(() => {\n\t\tconst container = containerRef.current;\n\t\tconst viewport = getViewport(container);\n\n\t\tif (!container || !viewport) {\n\t\t\treturn;\n\t\t}\n\n\t\tupdateScrollState(viewport);\n\n\t\tconst handleScroll = () => {\n\t\t\tif (!isUserScrolling.current) {\n\t\t\t\tupdateScrollState(viewport);\n\t\t\t}\n\t\t};\n\n\t\tconst handleTouchStart = () => {\n\t\t\tisUserScrolling.current = true;\n\t\t};\n\n\t\tconst handleTouchEnd = () => {\n\t\t\tisUserScrolling.current = false;\n\t\t\tupdateScrollState(viewport);\n\t\t};\n\n\t\tlet growthTimeout: number;\n\t\tconst observer = new MutationObserver(() => {\n\t\t\tisGrowing.current = true;\n\t\t\twindow.clearTimeout(growthTimeout);\n\n\t\t\tif (shouldAutoScroll && !isUserScrolling.current) {\n\t\t\t\tviewport.scrollTo({\n\t\t\t\t\ttop: viewport.scrollHeight,\n\n\t\t\t\t\tbehavior: \"instant\",\n\t\t\t\t});\n\t\t\t}\n\t\t\tupdateScrollState(viewport);\n\n\t\t\tgrowthTimeout = window.setTimeout(() => {\n\t\t\t\tisGrowing.current = false;\n\t\t\t}, 100);\n\t\t});\n\n\t\tviewport.addEventListener(\"scroll\", handleScroll, { passive: true });\n\t\tviewport.addEventListener(\"touchstart\", handleTouchStart);\n\t\tviewport.addEventListener(\"touchend\", handleTouchEnd);\n\n\t\tobserver.observe(container, {\n\t\t\tchildList: true,\n\t\t\tsubtree: true,\n\t\t\tattributes: true,\n\t\t\tcharacterData: true,\n\t\t});\n\n\t\treturn () => {\n\t\t\twindow.clearTimeout(growthTimeout);\n\t\t\tobserver.disconnect();\n\t\t\tviewport.removeEventListener(\"scroll\", handleScroll);\n\t\t\tviewport.removeEventListener(\"touchstart\", handleTouchStart);\n\t\t\tviewport.removeEventListener(\"touchend\", handleTouchEnd);\n\t\t};\n\t}, [getViewport, updateScrollState, shouldAutoScroll]);\n\n\tconst scrollToBottom = () => {\n\t\tconst viewport = getViewport(containerRef.current);\n\t\tif (!viewport) {\n\t\t\treturn;\n\t\t}\n\n\t\tsetShouldAutoScroll(true);\n\t\tviewport.scrollTo({\n\t\t\ttop: viewport.scrollHeight,\n\t\t\tbehavior: isGrowing.current ? \"instant\" : \"smooth\",\n\t\t});\n\t};\n\n\treturn [containerRef, showScrollButton, scrollToBottom];\n}\n",
      "type": "registry:hook",
      "target": ""
    }
  ]
}